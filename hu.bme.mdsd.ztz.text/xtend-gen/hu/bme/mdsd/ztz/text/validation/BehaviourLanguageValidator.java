/**
 * generated by Xtext 2.9.2
 */
package hu.bme.mdsd.ztz.text.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import hu.bme.mdsd.ztz.model.behaviour.BehaviourContainer;
import hu.bme.mdsd.ztz.model.behaviour.DynamicRobot;
import hu.bme.mdsd.ztz.model.behaviour.Message;
import hu.bme.mdsd.ztz.model.behaviour.RobotCollaboration;
import hu.bme.mdsd.ztz.model.drone.DronePackage;
import hu.bme.mdsd.ztz.text.behaviourLanguage.BehaviourLanguagePackage;
import hu.bme.mdsd.ztz.text.behaviourLanguage.CollaborationStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.Import;
import hu.bme.mdsd.ztz.text.manager.ResourceManager;
import hu.bme.mdsd.ztz.text.validation.AbstractBehaviourLanguageValidator;
import hu.bme.mdsd.ztz.text.validation.ErrorCodes;
import java.util.Iterator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BehaviourLanguageValidator extends AbstractBehaviourLanguageValidator {
  @Check
  public Resource handleImport(final Import imp) {
    Resource _xifexpression = null;
    String _importURI = imp.getImportURI();
    boolean _isEmpty = _importURI.isEmpty();
    if (_isEmpty) {
      this.error("Import cannot be empty", BehaviourLanguagePackage.Literals.IMPORT__IMPORT_URI, ErrorCodes.INVALID_IMPORT);
    } else {
      Resource _xifexpression_1 = null;
      String _importURI_1 = imp.getImportURI();
      ResourceManager _instance = ResourceManager.getInstance();
      String _acceptedDomain = _instance.getAcceptedDomain();
      boolean _endsWith = _importURI_1.endsWith(_acceptedDomain);
      if (_endsWith) {
        Resource _xblockexpression = null;
        {
          final ResourceManager manager = ResourceManager.getInstance();
          _xblockexpression = manager.load(imp);
        }
        _xifexpression_1 = _xblockexpression;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkSelfKnowing(final CollaborationStatement statement) {
    EList<RobotCollaboration> _collaboration = statement.getCollaboration();
    for (final RobotCollaboration collab : _collaboration) {
      DynamicRobot _robot = statement.getRobot();
      DynamicRobot _collaborator = collab.getCollaborator();
      boolean _equals = Objects.equal(_robot, _collaborator);
      if (_equals) {
        this.error("Robots cannot know themselves", BehaviourLanguagePackage.Literals.ATOMIC_STATEMENT__ROBOT, ErrorCodes.SAME_COLLABORATOR);
      }
    }
  }
  
  @Check
  public void checkUniqueRobotNames(final DynamicRobot robot) {
    EObject _eContainer = robot.eContainer();
    final BehaviourContainer container = ((BehaviourContainer) _eContainer);
    EList<DynamicRobot> _dynamicRobots = container.getDynamicRobots();
    for (final DynamicRobot otherRobot : _dynamicRobots) {
      boolean _notEquals = (!Objects.equal(otherRobot, robot));
      if (_notEquals) {
        String _name = otherRobot.getName();
        String _name_1 = robot.getName();
        boolean _equals = _name.equals(_name_1);
        if (_equals) {
          this.error("Robots cannot have the same name", robot, DronePackage.Literals.NAMED_ELEMENT__NAME, ErrorCodes.SAME_ROBOT_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkUniqueMessageNames(final Message message) {
    Resource _eResource = message.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    final Iterator<Message> messagesIterator = Iterators.<Message>filter(_allContents, Message.class);
    while (messagesIterator.hasNext()) {
      {
        Message otherMessage = messagesIterator.next();
        boolean _notEquals = (!Objects.equal(otherMessage, message));
        if (_notEquals) {
          String _name = otherMessage.getName();
          String _name_1 = message.getName();
          boolean _equals = _name.equals(_name_1);
          if (_equals) {
            this.error("Messages cannot have the same name", message, DronePackage.Literals.NAMED_ELEMENT__NAME, ErrorCodes.SAME_MESSAGE_NAME);
          }
        }
      }
    }
  }
}
