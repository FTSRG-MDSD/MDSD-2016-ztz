/*
 * generated by Xtext 2.9.2
 */
package hu.bme.mdsd.ztz.text.generator

import hu.bme.mdsd.ztz.model.behaviour.Action
import hu.bme.mdsd.ztz.model.behaviour.BehaviourContainer
import hu.bme.mdsd.ztz.model.behaviour.BehaviourFactory
import hu.bme.mdsd.ztz.model.behaviour.BehaviourPackage
import hu.bme.mdsd.ztz.model.behaviour.BroadcastCommunication
import hu.bme.mdsd.ztz.model.behaviour.DynamicRobot
import hu.bme.mdsd.ztz.model.behaviour.Message
import hu.bme.mdsd.ztz.model.behaviour.MessageRepository
import hu.bme.mdsd.ztz.model.behaviour.RobotCollaboration
import hu.bme.mdsd.ztz.model.behaviour.UnicastCommunication
import hu.bme.mdsd.ztz.model.drone.Robot
import hu.bme.mdsd.ztz.text.behaviourLanguage.ActionStatement
import hu.bme.mdsd.ztz.text.behaviourLanguage.AllTarget
import hu.bme.mdsd.ztz.text.behaviourLanguage.CollaborationStatement
import hu.bme.mdsd.ztz.text.behaviourLanguage.Import
import hu.bme.mdsd.ztz.text.behaviourLanguage.MessageStatement
import hu.bme.mdsd.ztz.text.behaviourLanguage.MultiTarget
import hu.bme.mdsd.ztz.text.behaviourLanguage.Statement
import hu.bme.mdsd.ztz.text.behaviourLanguage.UniTarget
import hu.bme.mdsd.ztz.text.manager.ResourceManager
import java.util.ArrayList
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.xtend.lib.annotations.Delegate
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BehaviourLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val manager = ResourceManager.instance
		importResource(resource, manager)

		generateBehaviour(resource, fsa)
	}

	protected def generateBehaviour(Resource resource, IFileSystemAccess2 fsa) {
		val Iterator<BehaviourContainer> containerIterator = resource.allContents.filter(typeof(BehaviourContainer))
		if (containerIterator.hasNext) {
			val container = containerIterator.next()

			val Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE
			val Map<String, Object> m = reg.getExtensionToFactoryMap()
			m.put("behaviour", new XMIResourceFactoryImpl())

			val ResourceSet resourceSet = new ResourceSetImpl();

			val resourceURI = fsa.getURI(ResourceManager.instance.modelFolder + "robots.behaviour")

			val resourceOfBehaviour = resourceSet.createResource(resourceURI)
			resourceOfBehaviour.getContents().clear()

			resourceOfBehaviour.getContents().add(container)

			parseStatements(resource, resourceOfBehaviour)

			resourceOfBehaviour.save(null)
		}
	}

	protected def parseStatements(Resource resource, Resource resourceOfBehaviour) {
		val Iterator<Statement> statementIter = resource.allContents.filter(typeof(Statement))

		while (statementIter.hasNext) {
			val statement = statementIter.next()
			statement.parseStatement(resourceOfBehaviour)
		}
	}

	def dispatch parseStatement(ActionStatement statement, Resource resourceOfBehaviour) {
		statement.robot.actions.add(statement.action)
		if (!statement.moreactions.empty) {
			statement.robot.actions.addAll(statement.moreactions)
		}
	}

	def dispatch parseStatement(MessageStatement statement, Resource resourceOfBehaviour) {
		val senderRobot = statement.robot
		initMessageRepository(senderRobot)

		val messageTarget = statement.target 
		val message = statement.message

		messageTarget.parseMessageTarget(senderRobot, message)
		
	}
	
	def MessageRepository initMessageRepository(DynamicRobot robot) {
		var MessageRepository messageRepository = robot.messageRepository
		
		if (robot.messageRepository == null) {
			messageRepository = BehaviourFactory.eINSTANCE.createMessageRepository()
			messageRepository.name = robot.name + "MessageRepository"
			messageRepository.robot = robot
		}
		return messageRepository
	}


	def dispatch parseMessageTarget(UniTarget target, DynamicRobot senderRobot, Message message) {
		println("uni target")
		if (!reachableRobot(senderRobot, target.target)) {
			println("not reachable")
			return null
		}
		target.target.initMessageRepository()
		val action = BehaviourFactory.eINSTANCE.createUnicastCommunication()
		action.message = message
		action.target = target.target
		senderRobot.addAction(action)
		addSendedMessage(senderRobot, message)
	}
	
	def dispatch parseMessageTarget(MultiTarget target, DynamicRobot senderRobot, Message message) {
		for (DynamicRobot targetRobot : target.target) {
			if (!reachableRobot(senderRobot, targetRobot)) {
				return null
			}
		}
		for (DynamicRobot targetRobot : target.target) {
			targetRobot.initMessageRepository()
		}
		val action = BehaviourFactory.eINSTANCE.createMulticastCommunication()
		action.message = message
		action.targets.addAll(target.target)
		senderRobot.addAction(action)
		addSendedMessage(senderRobot, message)
	}
	
	def dispatch parseMessageTarget(AllTarget target, DynamicRobot senderRobot, Message message) {
		if (senderRobot.collaborations.empty) {
			return null
		}
		val action = BehaviourFactory.eINSTANCE.createBroadcastCommunication
		action.message = message
		
		val Set<DynamicRobot> targetRobots = new HashSet<DynamicRobot>()
		for (RobotCollaboration collab : senderRobot.collaborations) {
			targetRobots.add(collab.collaborator)
		}
		
		for (DynamicRobot robot : targetRobots) {
			robot.initMessageRepository()
		}
		
		action.targets.addAll(targetRobots)
		senderRobot.addAction(action)
		addSendedMessage(senderRobot, message)
	}
	
	def addAction(DynamicRobot senderRobot, Action action) {
		senderRobot.actions.add(action)
	}


	def addSendedMessage(DynamicRobot senderRobot, Message message) {
		senderRobot.messageRepository.sendedMessages.add(message)
	}
	
	
	def boolean reachableRobot(DynamicRobot origin, DynamicRobot target) {
		for (RobotCollaboration collab : origin.collaborations) {
			if (collab.collaborator == target) {
				return true
			}
		}
		return false
	}

	def dispatch parseStatement(CollaborationStatement statement, Resource resourceOfBehaviour) {
		val robot = statement.robot

		val connectedRobots = new HashSet<DynamicRobot>()
		for (RobotCollaboration possibleCollaboration : statement.collaboration) {
			var inCollaboration = false
			for (RobotCollaboration collaboration : robot.collaborations) {
				if (collaboration.collaborator == possibleCollaboration.collaborator) {
					inCollaboration = true
				}
			}
			if (!inCollaboration) {
				if (robot != possibleCollaboration.collaborator) {
					connectedRobots.add(possibleCollaboration.collaborator)
				}
			}
		}

		for (DynamicRobot r : connectedRobots) {
			val newCollaboration = BehaviourFactory.eINSTANCE.createRobotCollaboration()
			newCollaboration.collaborator = r
			robot.collaborations.add(newCollaboration)

			val newOppositeCollaboration = BehaviourFactory.eINSTANCE.createRobotCollaboration()
			newOppositeCollaboration.collaborator = robot
			r.collaborations.add(newOppositeCollaboration)
		}
	}

	def protected importResource(Resource resource, ResourceManager manager) {
		val Iterator<Import> iterator = resource.allContents.filter(typeof(Import))
		if (iterator.hasNext) {
			val Import imp = iterator.next
			if (!imp.importURI.empty) {
				if (!manager.importedModelPath.equals(imp.importURI)) {
					manager.load(imp)
				}
			}
		}
	}
}
