package hu.bme.mdsd.ztz.model.constraints

import "http://www.mdsd.hu/drone"
import "http://www.mdsd.hu/behaviour"


@Constraint(
	key = {"measure"},
	severity = "error", 
	message = "$measure$ has the same converted measure!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sameMeasure(measure: MeasureDimension, convertedMeasure: MeasureDimension) {
	MeasureDimension.conversions.dimension(measure, convertedMeasure);
	convertedMeasure == measure;
}


@Constraint(
	key = {"conversion"},
	severity = "error",
	message = "Conversion rate must not be zero!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern nullMeasureConversionValue(conversion: MeasureConversion) {
	MeasureConversion.rate(conversion, rate);
	check (rate == 0.0);
}


@Constraint(
	key = {"taskExecution", "taskRequirement"},
	severity = "error",
	message = "The prerequisite task of $taskExecution$ is the same!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern sameTaskAsPrerequisite(taskRequirement: TaskRequirement, taskExecution: TaskExecution) {
	TaskRequirement.prerequisite(taskRequirement, taskExecution);
	TaskRequirement.task(taskRequirement, taskExecution);
}


@Constraint(
	key = {"requirement"},
	severity = "error",
	message = "The number of participants has to be positive!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern nonPositiveParticipants(requirement: TaskRequirement) {
	TaskRequirement.participants(requirement, participants);
	check(participants <= 0);
}




@Constraint(
	key = {"taskExecution"},
	severity = "error",
	message = "$taskExecution$ must not be in Waiting status when its prerequisite task is finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern incorrectWaitingTask(taskExecution: TaskExecution) {
	TaskRequirement.task(requirement, taskExecution);
	TaskExecution.status(taskExecution, ::Waiting);
	TaskRequirement.prerequisite.status(requirement, ::Finished);
}


@Constraint(
	key = {"taskExecution"},
	severity = "error",
	message = "$taskExecution$ must be waiting when its prerequisite is not finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern isNotWaitingTask(taskExecution: TaskExecution) {
	TaskRequirement.task(requirement, taskExecution);
	TaskExecution.status(taskExecution, status);
	TaskRequirement.prerequisite.status(requirement, preStatus);
	check(preStatus != hu.bme.mdsd.ztz.model.behaviour.TaskExecutionStatus.FINISHED && 
		status != hu.bme.mdsd.ztz.model.behaviour.TaskExecutionStatus.WAITING
	);
}


@Constraint(
	key = {"robot"},
	severity = "error",
	message = "The collaboration of $robot$ refers to itself!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern sameCollaboratorRobot(robot:DynamicRobot) {
	DynamicRobot.collaborations.collaborator(robot, robot);
}


@Constraint(
	key = {"detected1", "object"},
	severity = "error",
	message = "$object$ is detected more than once by the same robot!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern oneDetectedObject(object: AreaObject, detected1: DetectedObject) {
	DynamicRobot.detectedObjects(robot, detected1);
	DynamicRobot.detectedObjects(robot, detected2);
	detected1 != detected2;
	DetectedObject.object(detected1, object);
	DetectedObject.object(detected2, object);
}


@Constraint (
	key = {"robot", "task"},
	severity = "error",
	message = "$robot$ is not capable of executing linked task: $task$, capability of $capability$ is missing!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern robotCannotExecuteTask(robot: DynamicRobot, task: TaskExecution, capability: Capability) {
	TaskRequirement.task(requirement, task);
	TaskExecution.executors(task, robot);
	TaskRequirement.requiredCapabilities(requirement, capability);
	neg find robotHasCapability(robot, capability);
}

pattern robotHasCapability(robot: DynamicRobot, capability: Capability) {
	DynamicRobot.robot.capabilities(robot, capability);
}

//@Constraint (
//	key = {"robot", "task"},
//	severity = "error",
//	message = "$robot$ is executing unlinked task: $task$!",
//	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
//)
//pattern robotExecutingUnlinkedTask(robot: DynamicRobot, task: Task) {
//	DynamicRobot.execute(robot, taskExecution);
//	Task.execution(task, taskExecution);
//	neg find robotHasTask(robot, task);
//}

pattern robotHasTask(robot: Robot, task: Task) {
	Robot.tasks(robot, task);
}

@Constraint (
	key = {"robot"},
	severity = "warning",
	message = "$robot$ does not have any batteries!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern noBattery(robot: Robot) {
	neg find robotHasBattery(robot, _);
}

pattern robotHasBattery(robot: Robot, battery: Battery) {
	Robot.batteries(robot, battery);
}