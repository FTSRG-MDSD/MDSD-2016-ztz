package hu.bme.mdsd.ztz.model.constraints

import "http://www.mdsd.hu/drone"


@Constraint(
	key = {"measure"},
	severity = "error", 
	message = "$measure$ has the same converted measure!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sameMeasure(measure: MeasureDimension, convertedMeasure: MeasureDimension) {
	MeasureDimension.conversions.dimension(measure, convertedMeasure);
	convertedMeasure == measure;
}


@Constraint(
	key = {"conversion"},
	severity = "error",
	message = "Conversion rate must not be zero!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern nullMeasureConversionValue(conversion: MeasureConversion) {
	MeasureConversion.rate(conversion, rate);
	check (rate == 0.0);
}


@Constraint(
	key = {"task"},
	severity = "error",
	message = "The prerequisite task of $task$ is the same!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sameTaskAsPrerequisite(task: Task) {
	Task.requirement.prerequisite(task, task);
}


@Constraint(
	key = {"requirement"},
	severity = "error",
	message = "The number of participants has to be positive!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern nonPositiveParticipants(requirement: TaskRequirement) {
	TaskRequirement.participants(requirement, participants);
	check(participants <= 0);
}


@Constraint(
	key = {"task"},
	severity = "error",
	message = "$task$ must be finished when its execution status is finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern taskNotFinished(task:Task) {
	Task.execution.status(task, ::Finished);
	Task.status(task, status);
	check (status != hu.bme.mdsd.ztz.model.drone.TaskStatus.FINISHED);
}


@Constraint(
	key = {"task"},
	severity = "error",
	message = "$task$ mustn't be finished when its execution status is still not finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern taskEarlyFinished(task: Task) {
	Task.status(task, ::Finished);
	Task.execution.status(task, status);
	check (status != hu.bme.mdsd.ztz.model.drone.TaskExecutionStatus.FINISHED);
}


@Constraint(
	key = {"task", "execution"},
	severity = "error",
	message = "$task$ is in Waiting status, so it must not have a TaskExecution!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern taskEarlyExecuted(task:Task, execution: TaskExecution) {
	Task.status(task, ::Waiting);
	Task.execution(task, execution);
}


@Constraint(
	key = {"task"},
	severity = "error",
	message = "$task$ must not be in Waiting status when its prerequisite task is finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern incorrectWaitingTask(task: Task) {
	Task.requirement.prerequisite.status(task, ::Finished);
	Task.status(task, ::Waiting);
}


@Constraint(
	key = {"task"},
	severity = "error",
	message = "$task$ must be waiting when its prerequisite is not finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern isNotWaitingTask(task:Task) {
	Task.requirement.prerequisite.status(task, preStatus);
	Task.status(task, taskStatus);
	check(preStatus != hu.bme.mdsd.ztz.model.drone.TaskStatus.FINISHED && 
		taskStatus != hu.bme.mdsd.ztz.model.drone.TaskStatus.WAITING
	);
}


@Constraint(
	key = {"robot"},
	severity = "error",
	message = "The collaboration of $robot$ refers to itself!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sameCollaboratorRobot(robot:Robot) {
	Robot.collaborations.collaborator(robot, robot);
}


@Constraint(
	key = {"detected1", "object"},
	severity = "error",
	message = "$object$ is detected more than once by the same robot!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern oneDetectedObject(object: AreaObject, detected1: DetectedObject) {
	Robot.detectedObjects(robot, detected1);
	Robot.detectedObjects(robot, detected2);
	detected1 != detected2;
	DetectedObject.object(detected1, object);
	DetectedObject.object(detected2, object);
}


