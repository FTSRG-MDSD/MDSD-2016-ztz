package hu.bme.mdsd.ztz.model.constraints

import "http://www.mdsd.hu/drone"
import "http://www.mdsd.hu/behaviour"


@Constraint(
	key = {"measure"},
	severity = "error", 
	message = "$measure$ has the same converted measure!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sameMeasure(measure: MeasureDimension, convertedMeasure: MeasureDimension) {
	MeasureDimension.conversions.dimension(measure, convertedMeasure);
	convertedMeasure == measure;
}


@Constraint(
	key = {"conversion"},
	severity = "error",
	message = "Conversion rate must not be zero!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern nullMeasureConversionValue(conversion: MeasureConversion) {
	MeasureConversion.rate(conversion, rate);
	check (rate == 0.0);
}


@Constraint(
	key = {"taskExecution", "taskRequirement"},
	severity = "error",
	message = "The prerequisite task of $taskExecution$ is the same!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern sameTaskAsPrerequisite(taskRequirement: TaskRequirement, taskExecution: TaskExecution) {
	TaskRequirement.prerequisite(taskRequirement, taskExecution);
	TaskRequirement.taskExecution(taskRequirement, taskExecution);
}


@Constraint(
	key = {"requirement"},
	severity = "error",
	message = "The number of participants has to be positive!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern nonPositiveParticipants(requirement: TaskRequirement) {
	TaskRequirement.participants(requirement, participants);
	check(participants <= 0);
}




@Constraint(
	key = {"taskExecution"},
	severity = "error",
	message = "$taskExecution$ must not be in Waiting status when its prerequisite task is finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern incorrectWaitingTask(taskExecution: TaskExecution) {
	TaskRequirement.taskExecution(requirement, taskExecution);
	TaskExecution.status(taskExecution, ::Waiting);
	TaskRequirement.prerequisite.status(requirement, ::Finished);
}


@Constraint(
	key = {"taskExecution"},
	severity = "error",
	message = "$taskExecution$ must be waiting when its prerequisite is not finished!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern isNotWaitingTask(taskExecution: TaskExecution) {
	TaskRequirement.taskExecution(requirement, taskExecution);
	TaskExecution.status(taskExecution, status);
	TaskRequirement.prerequisite.status(requirement, preStatus);
	check(preStatus != hu.bme.mdsd.ztz.model.behaviour.TaskExecutionStatus.FINISHED && 
		status != hu.bme.mdsd.ztz.model.behaviour.TaskExecutionStatus.WAITING
	);
}


@Constraint(
	key = {"robot"},
	severity = "error",
	message = "The collaboration of $robot$ refers to itself!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern sameCollaboratorRobot(robot:DynamicRobot) {
	DynamicRobot.collaborations.collaborator(robot, robot);
}


@Constraint(
	key = {"detected1", "object"},
	severity = "error",
	message = "$object$ is detected more than once by the same robot!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern oneDetectedObject(object: AreaObject, detected1: DetectedObject) {
	DynamicRobot.detectedObjects(robot, detected1);
	DynamicRobot.detectedObjects(robot, detected2);
	detected1 != detected2;
	DetectedObject.object(detected1, object);
	DetectedObject.object(detected2, object);
}


@Constraint (
	key = {"robot", "taskExecution"},
	severity = "error",
	message = "$robot$ is not capable of executing linked task: $taskExecution$, capability of $capability$ is missing!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern robotCannotExecuteTask(robot: DynamicRobot, taskExecution: TaskExecution, capability: Capability) {
	TaskRequirement.taskExecution(requirement, taskExecution);
	TaskExecution.executors(taskExecution, robot);
	TaskRequirement.requiredCapabilities(requirement, capability);
	N1 == count find requiredCapability(requirement, capability);
	N2 == count find robotHasCapability(robot, capability);
	N1 != N2;
}

pattern requiredCapability(requirement:TaskRequirement, capability:Capability) {
	TaskRequirement.requiredCapabilities(requirement, capability);
}

pattern robotHasCapability(robot: DynamicRobot, capability: Capability) {
	DynamicRobot.robot.capabilities(robot, capability);
}

@Constraint (
	key = {"robot", "task"},
	severity = "error",
	message = "$robot$ is executing unlinked task: $task$!",
	targetEditorId = "hu.bme.mdsd.ztz.model.behaviour.presentation.BehaviourEditorID"
)
pattern robotExecutingUnlinkedTask(robot: DynamicRobot, task: Task) {
	DynamicRobot.executedTasks(robot, taskExecution);
	TaskExecution.task(taskExecution, task);
	neg find robotHasTask(robot, task);
}

pattern robotHasTask(robot: DynamicRobot, task: Task) {
	DynamicRobot.robot.tasks(robot, task);
}

@Constraint (
	key = {"robot"},
	severity = "warning",
	message = "$robot$ does not have any batteries!",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern noBattery(robot: Robot) {
	neg find robotHasBattery(robot, _);
}

pattern robotHasBattery(robot: Robot, battery: Battery) {
	Robot.batteries(robot, battery);
}

@Constraint (
	key = {"robot", "size"},
	severity = "warning",
	message = "Size dimensions of $robot$ are not equal.",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sizeDimensionsDiffer(robot: Robot, size: Size) {
	Robot.size(robot, size);
	Size.height.dimension(size, heightDim);
	Size.length.dimension(size, lengthDim);
	
	heightDim != lengthDim;
} or {
	Robot.size(robot, size);
	Size.height.dimension(size, heightDim);
	Size.width.dimension(size, widthDim);
	
	heightDim != widthDim;
} or {
	Robot.size(robot, size);
	Size.length.dimension(size, lengthDim);
	Size.width.dimension(size, widthDim);
	
	lengthDim != widthDim;
}

@Constraint (
	key = {"robot", "size"},
	severity = "error",
	message = "Size dimensions of $robot$ are not compatible (cannot be converted).",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern sizeDimensionsNotCompatible(robot: Robot, size: Size) {
	find sizeDimensionsDiffer(robot, size);
	Size.height.dimension(size, heightDim);
	Size.length.dimension(size, lengthDim);
	heightDim != lengthDim;
	neg find conversionAvailable(heightDim, lengthDim);
} or {
	find sizeDimensionsDiffer(robot, size);
	Size.height.dimension(size, heightDim);
	Size.width.dimension(size, widthDim);
	heightDim != widthDim;
	neg find conversionAvailable(heightDim, widthDim);
} or {
	find sizeDimensionsDiffer(robot, size);
	Size.length.dimension(size, lengthDim);
	Size.width.dimension(size, widthDim);
	lengthDim != widthDim;
	neg find conversionAvailable(lengthDim, widthDim);
}

pattern directConversionAvailable(dim1: MeasureDimension, dim2: MeasureDimension) {
	MeasureDimension.conversions.dimension(dim1, dim2);
} or {
	MeasureDimension.conversions.dimension(dim2, dim1);
}

pattern conversionAvailable(dim1: MeasureDimension, dim2: MeasureDimension) {
	find directConversionAvailable+(dim1, dim2);
	dim1 != dim2;
}

@Constraint(
	key = {"robot", "collaborator"},
	severity = "error",
	message = "Communication range dimensions of $robot$ and $collaborator$ are not compatible (cannot be directly converted).",
	targetEditorId = "hu.bme.mdsd.ztz.model.drone.presentation.DroneEditorID"
)
pattern collaboratorRangeDimensionsNotCompatible(robot: Robot, collaborator: Robot) {
	DynamicRobot.collaborations(drobot, robotCollaboration);
	DynamicRobot.robot(drobot, robot);
	Robot.communicationRange.dimension(robot, dim1);
	
	RobotCollaboration.collaborator(robotCollaboration, dcollaborator);
	DynamicRobot.robot(dcollaborator, collaborator);
	Robot.communicationRange.dimension(collaborator, dim2);
	
	neg find directConversionAvailable(dim1, dim2);
	
}
