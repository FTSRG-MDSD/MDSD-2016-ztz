/**
 * generated by Xtext 2.9.2
 */
package hu.bme.mdsd.ztz.text.ui.quickfix;

import com.google.common.collect.Iterators;
import hu.bme.mdsd.ztz.model.behaviour.BehaviourFactory;
import hu.bme.mdsd.ztz.model.behaviour.DynamicRobot;
import hu.bme.mdsd.ztz.model.behaviour.RobotCollaboration;
import hu.bme.mdsd.ztz.model.drone.DroneFactory;
import hu.bme.mdsd.ztz.model.drone.Property;
import hu.bme.mdsd.ztz.model.drone.PropertyKey;
import hu.bme.mdsd.ztz.model.drone.StringValue;
import hu.bme.mdsd.ztz.text.behaviourLanguage.ActionDeclarationStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.ActionImplementation;
import hu.bme.mdsd.ztz.text.behaviourLanguage.AtomicStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.BehaviourLanguage;
import hu.bme.mdsd.ztz.text.behaviourLanguage.BehaviourLanguageFactory;
import hu.bme.mdsd.ztz.text.behaviourLanguage.CollaborationStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.ConditionalStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.MessageStatement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.MessageTarget;
import hu.bme.mdsd.ztz.text.behaviourLanguage.Statement;
import hu.bme.mdsd.ztz.text.behaviourLanguage.SynchronousStatement;
import hu.bme.mdsd.ztz.text.validation.ErrorCodes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification;
import org.eclipse.xtext.ui.editor.model.edit.IssueModificationContext;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#quick-fixes
 */
@SuppressWarnings("all")
public class BehaviourLanguageQuickfixProvider extends DefaultQuickfixProvider {
  @Fix(ErrorCodes.NOT_IN_COLLABORATION)
  public void fixMissingCollaboration(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final MessageTarget messageTarget = ((MessageTarget) element);
      EObject _eContainer = messageTarget.eContainer();
      final MessageStatement statement = ((MessageStatement) _eContainer);
      EObject _eContainer_1 = statement.eContainer();
      final BehaviourLanguage language = ((BehaviourLanguage) _eContainer_1);
      Resource _eResource = messageTarget.eResource();
      TreeIterator<EObject> _allContents = _eResource.getAllContents();
      Iterator<DynamicRobot> _filter = Iterators.<DynamicRobot>filter(_allContents, DynamicRobot.class);
      final Set<DynamicRobot> robots = IteratorExtensions.<DynamicRobot>toSet(_filter);
      DynamicRobot target = null;
      for (final DynamicRobot r : robots) {
        String[] _data = issue.getData();
        String _get = _data[0];
        String _name = r.getName();
        boolean _equals = _get.equals(_name);
        if (_equals) {
          target = r;
        }
      }
      final CollaborationStatement newCollaborationStatement = BehaviourLanguageFactory.eINSTANCE.createCollaborationStatement();
      DynamicRobot _robot = statement.getRobot();
      newCollaborationStatement.setRobot(_robot);
      final RobotCollaboration newCollaboration = BehaviourFactory.eINSTANCE.createRobotCollaboration();
      newCollaboration.setCollaborator(target);
      EList<RobotCollaboration> _collaboration = newCollaborationStatement.getCollaboration();
      _collaboration.add(newCollaboration);
      EList<Statement> _statements = language.getStatements();
      _statements.add(0, newCollaborationStatement);
    };
    acceptor.accept(issue, "Add new collaboration", "", "", _function);
  }
  
  @Fix(ErrorCodes.MISSING_ACTION_DECLARATION)
  public void fixMissingActionDeclaration(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final ActionImplementation actionImp = ((ActionImplementation) element);
      final IXtextDocument document = context.getXtextDocument();
      Integer _offset = issue.getOffset();
      Integer _length = issue.getLength();
      final String actionName = document.get((_offset).intValue(), (_length).intValue());
      Resource _eResource = actionImp.eResource();
      EList<EObject> _contents = _eResource.getContents();
      EObject _get = _contents.get(0);
      final BehaviourLanguage language = ((BehaviourLanguage) _get);
      final ActionDeclarationStatement newActionDeclaration = BehaviourLanguageFactory.eINSTANCE.createActionDeclarationStatement();
      newActionDeclaration.setName(actionName);
      EList<PropertyKey> _properties = newActionDeclaration.getProperties();
      ActionDeclarationStatement _declaration = actionImp.getDeclaration();
      EList<PropertyKey> _properties_1 = _declaration.getProperties();
      _properties.addAll(_properties_1);
      EList<Statement> _statements = language.getStatements();
      _statements.add(0, newActionDeclaration);
    };
    acceptor.accept(issue, "Add new action", "", "", _function);
  }
  
  @Fix(ErrorCodes.SAME_COLLABORATOR)
  public void fixSelfCollaboration(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    String[] _data = issue.getData();
    String _get = _data[0];
    String _plus = ("Change the collaborator to " + _get);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final IXtextDocument xtextDocument = context.getXtextDocument();
      Integer _offset = issue.getOffset();
      Integer _length = issue.getLength();
      String[] _data_1 = issue.getData();
      String _get_1 = _data_1[0];
      xtextDocument.replace((_offset).intValue(), (_length).intValue(), _get_1);
    };
    acceptor.accept(issue, _plus, "", "", _function);
  }
  
  @Fix(ErrorCodes.SAME_MESSAGE_TARGET_WITH_COLLABORATIONS)
  public void fixSelfMessageTarget(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String[] _data = issue.getData();
    String _get = _data[0];
    String _plus = ("Change the target to " + _get);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final IXtextDocument xtextDocument = context.getXtextDocument();
      Integer _offset = issue.getOffset();
      Integer _length = issue.getLength();
      String[] _data_1 = issue.getData();
      String _get_1 = _data_1[0];
      xtextDocument.replace((_offset).intValue(), (_length).intValue(), _get_1);
    };
    acceptor.accept(issue, _plus, "", "", _function);
  }
  
  @Fix(ErrorCodes.SAME_ROBOT_STATEMENTS_IN_SYNC)
  public void fixSameRobotStatementsInSync(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      EObject _eContainer = element.eContainer();
      final SynchronousStatement synchStatement = ((SynchronousStatement) _eContainer);
      EList<AtomicStatement> _statements = synchStatement.getStatements();
      _statements.remove(element);
      EObject _eContainer_1 = synchStatement.eContainer();
      this.addNewStatement(_eContainer_1, synchStatement, ((Statement) element), false);
    };
    acceptor.accept(issue, "Move statement before the synchronous statement", "", "", _function);
    final ISemanticModification _function_1 = (EObject element, IModificationContext context) -> {
      EObject _eContainer = element.eContainer();
      final SynchronousStatement synchStatement = ((SynchronousStatement) _eContainer);
      EList<AtomicStatement> _statements = synchStatement.getStatements();
      _statements.remove(element);
      EObject _eContainer_1 = synchStatement.eContainer();
      this.addNewStatement(_eContainer_1, synchStatement, ((Statement) element), true);
    };
    acceptor.accept(issue, "Move statement after the synchronous statement", "", "", _function_1);
  }
  
  protected void _addNewStatement(final BehaviourLanguage container, final SynchronousStatement sync, final Statement statement, final boolean after) {
    EList<Statement> _statements = container.getStatements();
    int index = _statements.indexOf(sync);
    if (after) {
      index++;
    }
    EList<Statement> _statements_1 = container.getStatements();
    _statements_1.add(index, statement);
  }
  
  protected void _addNewStatement(final ConditionalStatement container, final SynchronousStatement sync, final Statement statement, final boolean after) {
    EList<Statement> _statements = container.getStatements();
    int index = _statements.indexOf(sync);
    if (after) {
      index++;
    }
    EList<Statement> _statements_1 = container.getStatements();
    _statements_1.add(index, statement);
  }
  
  @Fix(ErrorCodes.FEWER_ACTION_PROPERTIES)
  public void fixMissingActionProperties(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final ActionImplementation actionImp = ((ActionImplementation) element);
      this.changeActionProperties(actionImp, false);
    };
    acceptor.accept(issue, "Add the rest of the required properties", "", "", _function);
    final ISemanticModification _function_1 = (EObject element, IModificationContext context) -> {
      final ActionImplementation actionImp = ((ActionImplementation) element);
      this.changeActionProperties(actionImp, true);
    };
    acceptor.accept(issue, "Add the rest of the required properties and remove the superfluous ones", "", "", _function_1);
  }
  
  protected void changeActionProperties(final ActionImplementation actionImp, final boolean removeIncorrectProperties) {
    final Map<PropertyKey, Integer> keys = this.getPropertyKeys(actionImp);
    final ArrayList<PropertyKey> newKeys = this.getMissingKeys(actionImp, keys);
    for (final PropertyKey key : newKeys) {
      {
        Property property = DroneFactory.eINSTANCE.createProperty();
        property.setKey(key);
        final StringValue propertyStringValue = DroneFactory.eINSTANCE.createStringValue();
        propertyStringValue.setValue("");
        property.setValue(propertyStringValue);
        EList<Property> _properties = actionImp.getProperties();
        _properties.add(property);
      }
    }
    if (removeIncorrectProperties) {
      final ArrayList<Property> incorrectProperties = new ArrayList<Property>();
      EList<Property> _properties = actionImp.getProperties();
      for (final Property property : _properties) {
        ActionDeclarationStatement _declaration = actionImp.getDeclaration();
        EList<PropertyKey> _properties_1 = _declaration.getProperties();
        PropertyKey _key = property.getKey();
        boolean _contains = _properties_1.contains(_key);
        boolean _not = (!_contains);
        if (_not) {
          incorrectProperties.add(property);
        }
      }
      for (final Property property_1 : incorrectProperties) {
        EList<Property> _properties_2 = actionImp.getProperties();
        _properties_2.remove(property_1);
      }
    }
  }
  
  protected ArrayList<PropertyKey> getMissingKeys(final ActionImplementation actionImp, final Map<PropertyKey, Integer> keys) {
    final ArrayList<PropertyKey> newKeys = new ArrayList<PropertyKey>();
    ActionDeclarationStatement _declaration = actionImp.getDeclaration();
    EList<PropertyKey> _properties = _declaration.getProperties();
    for (final PropertyKey key : _properties) {
      boolean _containsKey = keys.containsKey(key);
      boolean _not = (!_containsKey);
      if (_not) {
        newKeys.add(key);
      }
    }
    return newKeys;
  }
  
  protected Map<PropertyKey, Integer> getPropertyKeys(final ActionImplementation actionImp) {
    final Map<PropertyKey, Integer> keys = new HashMap<PropertyKey, Integer>();
    EList<Property> _properties = actionImp.getProperties();
    for (final Property property : _properties) {
      PropertyKey _key = property.getKey();
      keys.put(_key, Integer.valueOf(1));
    }
    return keys;
  }
  
  @Fix(ErrorCodes.NOT_THE_SAME_ACTION_PROPERTIES)
  public void fixIncorrectActionProperties(final Issue issue, final IssueResolutionAcceptor acceptor) {
    IssueModificationContext.Factory _modificationContextFactory = this.getModificationContextFactory();
    _modificationContextFactory.createModificationContext(issue);
    final ISemanticModification _function = (EObject element, IModificationContext context) -> {
      final ActionImplementation actionImp = ((ActionImplementation) element);
      this.changeActionProperties(actionImp, true);
    };
    acceptor.accept(issue, "Change the properties", "", "", _function);
  }
  
  public void addNewStatement(final EObject container, final SynchronousStatement sync, final Statement statement, final boolean after) {
    if (container instanceof ConditionalStatement) {
      _addNewStatement((ConditionalStatement)container, sync, statement, after);
      return;
    } else if (container instanceof BehaviourLanguage) {
      _addNewStatement((BehaviourLanguage)container, sync, statement, after);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(container, sync, statement, after).toString());
    }
  }
}
